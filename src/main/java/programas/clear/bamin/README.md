# 1

- 문자열로 된 이진수를 입력받아, 아래의 규칙에 따라 0으로 만드는 횟수를 출력하는 프로그램
    - 짝수일 경우 나누기 2를 한다 (8 -> 4)
    - 홀수일 경우 빼기 1을 한다 (7 -> 6)
    - 이진수는 0으로 시작할 수도 있다 (ex 011000)

- ex) "011100" 입력
    - 십진수 28
    - 1) 28 / 2 -> 14
    - 2) 14 / 2 - > 7
    - 3) 7 - 1 -> 6
    - 4) 6 / 2 -> 3
    - 5) 3 - 1 -> 2
    - 6) 2 / 2 -> 1
    - 7) 1 - 1 -> 0
    - return 으로 횟수인 7 출력
- 

```java
public int solution(String S) {
   
}
```

# 2

- input String을 받아 output String으로 파싱하는 프로그램
- 이름, 확장자, 도시, 날짜로 구성된 input String
- 이름은 중복일 수 있다.
- 위와 같은 형식의 문자열 여러개가 개행문자로 구분되어 하나의 input String으로 주어진다
- 이를 파싱하여 output String과 같은 형식으로 출력한다
    - 도시 별로 묶어, 시간이 오래된 순으로 1번부터 인덱싱을 붙인다
        - 만약, 하나의 도시에 속한 값이 10개 이상일 경우 01, 02, ... ,10로 인덱스를 붙인다
            - 10개 미만일 경우 1, 2, ... ,9
            - 데이터는 100개를 초과하지 않는다
    - 확장자는 그대로 잔존해야한다
        - 확장자는 jpg, png, jpeg 세 개중 하나이다
    - 날짜는 2000년 부터 2020년 까지이다
    - output 출력 시, input의 순서가 보존되어야 한다

- input String

```
"photo.jpg, seoul, 2018-11-10 08:00:05
wow.png, newyork, 2018-10-15 12:15:05
a.jpg, seoul, 2018-10-07 12:15:05
b.jpg, paris, 2016-10-09 17:15:44
c.jpg, paris, 2016-07-13 19:15:22
d.jpg, seoul, 2018-06-14 17:18:22
e.jpg, seoul, 2018-08-22 13:11:13
1111.jpg, paris, 2018-10-14 12:15:05
f.jpg, seoul, 2018-09-11 14:02:12
g.png, seoul, 2018-05-11 09:02:23
h.jpeg, seoul, 2018-02-11 07:02:44
i.jpg, seoul, 2017-10-14 12:17:07
j.jpg, seoul, 2017-10-14 12:16:02
k.jpg, seoul, 2017-10-14 12:15:05"
```

- output String

```
Seoul10.jpg
Newyork1.png
Seoul09.jpg
Paris2.jpg
Paris1.jpg
Seoul06.jpg
Seoul07.jpg
Paris3.jpg
Seoul08.jpg
Seoul05.png
Seoul04.jpeg
Seoul03.jpg
Seoul02.jpg
Seoul01.jpg
```

- output의 Name 형식은 capitalize

```java
public String solution(String S) {
    
}
```

# 3

- 엘리베이터가 멈춘 횟수를 출력해주는 프로그램

- input에 대한 설명
    - 엘리베이터 탑승을 대기하는 승객 목록
        - 배열 A   // 승객들의 몸무게
        - 배열 B   // 승객들의 하차할 층

    - M     // 엘리베이터 최고 높이
    - X     // 엘리베이터 최대 탑승 가능한 사람 수 (X까지 탑승 가능하다. 미만이 아니라 이하)
    - Y     // 엘리베이터 최대 탑승 가능한 사람들의 무게 (Y까지 탑승 가능하다. 미만이 아니라 이하)

- 사람들은 Queue로 되어있다고 가정한다.
    - 즉, 배열 상의 인덱스가 가장 먼저 있는 사람이 가장 먼저 탑승하게 된다.
        - ex)
        - A [60, 80, 40, 40]
        - B [1, 2, 1, 2]
        - M = 3, X = 2, Y = 100 일때
            - 0번째 사람과 2번째 사람을 태우고 싶겠지만 그럴 수 없다.
            - 0번째 사람을 태우고, 1번째 사람을 태우려 할 때 무게 초과이므로 0번째 사람만 태우고 엘리베이터는 출발하게 된다.
            - 또한 0층(로비층) 에 도착하는 것도 하나의 횟수로 친다.
                - 이 경우, 0번째 탑승객을 태우고 `1층` 갔다가 `0층`옴
                - 다음 1번째 탑승객 태우고 `2층` 갔다가 `0층` 옴
                - 다음 2번째, 3번째 탑승객 태우고 `1층` 갔다가 `2층` 갔다가 `0층` 옴
                - 즉 답은 **7번**
    
```java
public int solution(int[] A, int[] B, int M, int X, int Y) {

}
```

# 4

- 다음 프로그램은 non descending으로 정렬된 A라는 배열에서 X라는 value의 index를 찾는 함수이다.
- 이를테면 
    - A = [1, 4, 10, 15]
    - `X가 15`로 주어진다면 답으로 `3`을 출력하면 됨
    - 만약 없는 배열 A에 포함되지 않은 숫자를 X로 주면(예를들어 5 이런거)
    - `-1`을 출력해야한다.

- 아래의 프로그램은 어딘가 오류가 있다.
- 추가, 삭제가 불가능하고 오로지 수정만 가능하다.
- 수정은 최대 3줄까지 가능하다.
- 에러를 디버깅하여 수정하세요.

```java
int solution(int[] A, int X) {
        int N = A.length;
        if (N == 0) {
            return -1;
        }
        int l = 0;
        int r = N - 1;
        while (l < r) {
            int m = (l + r) / 2;
            if (A[m] > X) {
                r = m - 1;
            } else {
                l = m;
            }
        }
        if (A[l] == X) {
            return l;
        }
        return -1;
    }
```